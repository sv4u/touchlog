package cli

import (
	"context"
	"fmt"

	"github.com/sv4u/touchlog/v2/internal/version"
	cli3 "github.com/urfave/cli/v3"
)

// BuildRootCommand builds the root CLI command
func BuildRootCommand() *cli3.Command {
	return &cli3.Command{
		Name:  "touchlog",
		Usage: "A knowledge graph note-taking system",
		Flags: []cli3.Flag{
			&cli3.StringFlag{
				Name:  "vault",
				Usage: "Path to vault root (default: auto-detect)",
			},
		},
		Commands: []*cli3.Command{
			buildVersionCommand(),
			buildCompletionCommand(),
			BuildInitCommand(),
			BuildNewCommand(),
			BuildEditCommand(),
			BuildIndexCommand(),
			BuildQueryCommand(),
			BuildViewCommand(),
			BuildGraphCommand(),
			BuildDiagnosticsCommand(),
			BuildDaemonCommand(),
		},
		EnableShellCompletion: true,
		Suggest:               true, // Enable command suggestions
	}
}

// buildVersionCommand builds the version command
func buildVersionCommand() *cli3.Command {
	return &cli3.Command{
		Name:  "version",
		Usage: "Show version information",
		Action: func(ctx context.Context, cmd *cli3.Command) error {
			fmt.Printf("touchlog version %s\n", version.GetVersion())
			return nil
		},
	}
}

// buildCompletionCommand builds the shell completion command
func buildCompletionCommand() *cli3.Command {
	return &cli3.Command{
		Name:  "completion",
		Usage: "Generate shell completion scripts",
		Commands: []*cli3.Command{
			{
				Name:  "bash",
				Usage: "Generate bash completion script",
				Action: func(ctx context.Context, cmd *cli3.Command) error {
					// For Phase 1, output a basic completion script
					// Full completion will be generated by urfave/cli v3
					fmt.Println("# touchlog bash completion")
					fmt.Println("_touchlog_completion() {")
					fmt.Println("  COMPREPLY=($(compgen -W \"version completion init new\" -- \"${COMP_WORDS[COMP_CWORD]}\"))")
					fmt.Println("}")
					fmt.Println("complete -F _touchlog_completion touchlog")
					return nil
				},
			},
			{
				Name:  "zsh",
				Usage: "Generate zsh completion script",
				Action: func(ctx context.Context, cmd *cli3.Command) error {
					fmt.Println("# touchlog zsh completion")
					fmt.Println("_touchlog() {")
					fmt.Println("  local -a commands")
					fmt.Println("  commands=(")
					fmt.Println("    'version:Show version information'")
					fmt.Println("    'completion:Generate shell completion scripts'")
					fmt.Println("    'init:Initialize a new vault'")
					fmt.Println("    'new:Create a new note'")
					fmt.Println("  )")
					fmt.Println("  _describe 'commands' commands")
					fmt.Println("}")
					fmt.Println("compdef _touchlog touchlog")
					return nil
				},
			},
			{
				Name:  "fish",
				Usage: "Generate fish completion script",
				Action: func(ctx context.Context, cmd *cli3.Command) error {
					fmt.Println("# touchlog fish completion")
					fmt.Println("complete -c touchlog -f -a version -d 'Show version information'")
					fmt.Println("complete -c touchlog -f -a completion -d 'Generate shell completion scripts'")
					fmt.Println("complete -c touchlog -f -a init -d 'Initialize a new vault'")
					fmt.Println("complete -c touchlog -f -a new -d 'Create a new note'")
					return nil
				},
			},
		},
	}
}

// GetVaultFromContext extracts the vault path from the CLI context
// The vault flag is on the root command, so we need to check the root
func GetVaultFromContext(ctx context.Context, cmd *cli3.Command) (string, error) {
	// Get the root command to access global flags
	root := cmd.Root()
	vaultFlag := root.String("vault")
	return ResolveVault(vaultFlag)
}
