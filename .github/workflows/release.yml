name: Release

on:
  workflow_dispatch:
    inputs:
      release_mode:
        description: 'Release mode: auto-increment version or use custom tag'
        required: true
        type: choice
        options:
          - auto-increment
          - custom-tag
      release_type:
        description: 'Release type for auto-increment (only used when release_mode = auto-increment)'
        required: true
        type: choice
        options:
          - major
          - minor
          - hotfix
        default: minor
      custom_tag:
        description: 'Custom tag in vX.Y.Z format (only used when release_mode = custom-tag)'
        required: false
        type: string
        default: ''
      dry_run:
        description: 'Run in dry-run mode (no tags, releases, or commits)'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: write
      id-token: write
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache-dependency-path: go.sum
          cache: true

      - name: Verify branch and working directory
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "master" ] && [ "$CURRENT_BRANCH" != "main" ]; then
            echo "[X] Error: This workflow must be run from the 'master' or 'main' branch"
            echo "Current branch: $CURRENT_BRANCH"
            exit 1
          fi
          
          if ! git diff-index --quiet HEAD --; then
            echo "[X] Error: Working directory is not clean. Please commit or stash changes."
            git status
            exit 1
          fi
          
          git fetch origin $CURRENT_BRANCH
          LOCAL=$(git rev-parse HEAD)
          REMOTE=$(git rev-parse origin/$CURRENT_BRANCH)
          if [ "$LOCAL" != "$REMOTE" ]; then
            echo "[X] Error: Local branch is not up-to-date with remote. Please pull latest changes."
            echo "Local: $LOCAL"
            echo "Remote: $REMOTE"
            exit 1
          fi
          
          echo "[OK] Branch verification passed"

      - name: Calculate version
        id: version
        run: |
          git fetch --tags
          
          if [ "${{ inputs.release_mode }}" = "auto-increment" ]; then
            LATEST_TAG=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || \
                         git describe --tags --abbrev=0 2>/dev/null || \
                         echo "v0.0.0")
            
            if [ "$LATEST_TAG" = "v0.0.0" ]; then
              NEXT_VERSION="0.1.0"
              NEXT_TAG="v0.1.0"
              echo "First release detected. Defaulting to v0.1.0"
            else
              VERSION=${LATEST_TAG#v}
              
              if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
                echo "[X] Error: Invalid version format: $VERSION"
                exit 1
              fi
              
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
              
              RELEASE_TYPE="${{ inputs.release_type }}"
              case "$RELEASE_TYPE" in
                major)
                  MAJOR=$((10#$MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  ;;
                minor)
                  MINOR=$((10#$MINOR + 1))
                  PATCH=0
                  ;;
                hotfix)
                  PATCH=$((10#$PATCH + 1))
                  ;;
                *)
                  echo "[X] Error: Invalid release type: $RELEASE_TYPE"
                  exit 1
                  ;;
              esac
              
              NEXT_VERSION="$MAJOR.$MINOR.$PATCH"
              NEXT_TAG="v$NEXT_VERSION"
            fi
          else
            CUSTOM_TAG="${{ inputs.custom_tag }}"
            
            if [ -z "$CUSTOM_TAG" ]; then
              echo "[X] Error: custom_tag is required when release_mode = custom-tag"
              exit 1
            fi
            
            if ! echo "$CUSTOM_TAG" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "[X] Error: Invalid tag format: $CUSTOM_TAG"
              echo "   Tag must match pattern: vX.Y.Z (e.g., v1.2.3)"
              exit 1
            fi
            
            NEXT_TAG="$CUSTOM_TAG"
            NEXT_VERSION=${CUSTOM_TAG#v}
          fi
          
          echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next tag: $NEXT_TAG"
          echo "Next version: $NEXT_VERSION"

      - name: Pre-release module validation
        run: go mod verify

      - name: Check commit range
        id: commit-range
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || \
                       git describe --tags --abbrev=0 2>/dev/null || \
                       echo "v0.0.0")
          
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "0")
          else
            COMMIT_COUNT=$(git rev-list --count ${LATEST_TAG}..HEAD 2>/dev/null || echo "0")
          fi
          
          if [ "$COMMIT_COUNT" -eq 0 ] && [ "$LATEST_TAG" != "v0.0.0" ]; then
            echo "[X] Error: No commits to release"
            echo "   No commits since $LATEST_TAG"
            exit 1
          fi
          
          echo "count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "Commit count: $COMMIT_COUNT"

      - name: Check if tag exists
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          
          if git rev-parse --verify "$NEXT_TAG" >/dev/null 2>&1; then
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "[!] Warning: Tag $NEXT_TAG already exists locally (dry-run mode, continuing)"
            else
              echo "[X] Error: Tag $NEXT_TAG already exists locally!"
              exit 1
            fi
          fi
          
          if git ls-remote --tags origin "$NEXT_TAG" | grep -q "$NEXT_TAG"; then
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "[!] Warning: Tag $NEXT_TAG already exists on remote (dry-run mode, continuing)"
            else
              echo "[X] Error: Tag $NEXT_TAG already exists on remote!"
              exit 1
            fi
          fi
          
          if [ "${{ inputs.dry_run }}" != "true" ]; then
            echo "[OK] Tag $NEXT_TAG is available"
          fi

      - name: Validate GoReleaser configuration
        uses: goreleaser/goreleaser-action@v5
        with:
          distribution: goreleaser
          version: "~> v2"
          args: check
        continue-on-error: false

      - name: Display release preview
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          NEXT_VERSION="${{ steps.version.outputs.version }}"
          COMMIT_COUNT="${{ steps.commit-range.outputs.count }}"
          DRY_RUN="${{ inputs.dry_run }}"
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          if [ "$DRY_RUN" = "true" ]; then
            echo "[?] DRY-RUN MODE - PREVIEW ONLY"
          else
            echo "[PKG] RELEASE PREVIEW"
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Release Mode:    ${{ inputs.release_mode }}"
          if [ "${{ inputs.release_mode }}" = "auto-increment" ]; then
            echo "Release Type:    ${{ inputs.release_type }}"
          fi
          echo "Next Version:    $NEXT_TAG"
          echo "Commits:         $COMMIT_COUNT commits"
          echo ""
          if [ "$DRY_RUN" = "true" ]; then
            echo "[i] In dry-run mode, no tags or releases will be created."
          else
            echo "[!] This will create and push tag: $NEXT_TAG"
            echo "    Waiting 10 seconds before proceeding..."
            sleep 10
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Create and push tag
        if: ${{ inputs.dry_run != 'true' }}
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          COMMIT_COUNT="${{ steps.commit-range.outputs.count }}"
          CURRENT_DATE=$(date +%Y-%m-%d)
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TAG_MESSAGE=$(printf "Release %s - %s\n\nAutomated release via GitHub Actions workflow.\nIncludes %s commits." "$NEXT_TAG" "$CURRENT_DATE" "$COMMIT_COUNT")
          
          git tag -a "$NEXT_TAG" -m "$TAG_MESSAGE"
          git push origin "$NEXT_TAG"
          
          MAX_RETRIES=5
          RETRY_DELAY=2
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git ls-remote --tags origin "$NEXT_TAG" | grep -q "$NEXT_TAG"; then
              echo "[OK] Tag $NEXT_TAG verified on remote"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "[...] Tag not yet visible, retrying in ${RETRY_DELAY}s (attempt $RETRY_COUNT/$MAX_RETRIES)..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "[X] Error: Tag push verification failed after $MAX_RETRIES attempts."
            exit 1
          fi

      - name: Checkout tag for build
        if: ${{ inputs.dry_run != 'true' }}
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          
          echo "Checking out tag $NEXT_TAG to ensure correct version is used..."
          
          # Fetch the tag to ensure it's available locally
          git fetch origin "$NEXT_TAG"
          
          # Checkout the tag (this puts us in detached HEAD state, which is fine for building)
          git checkout "$NEXT_TAG"
          
          echo "[OK] Checked out tag $NEXT_TAG"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Current tag: $(git describe --tags --exact-match HEAD 2>/dev/null || echo 'none')"

      - name: Trigger Go module indexing
        if: ${{ inputs.dry_run != 'true' }}
        continue-on-error: true
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          MODULE_PATH="github.com/sv4u/touchlog/v2"
          
          echo "Triggering Go module indexing for $MODULE_PATH@${NEXT_TAG}..."
          echo "Using GOPROXY=direct to force fetch from source"
          
          MAX_RETRIES=10
          RETRY_COUNT=0
          SUCCESS=false
          
          # Exponential backoff delays: 2s, 4s, 8s, 16s, 32s, 60s, 60s, 60s, 60s, 60s
          # Cap at 60 seconds per retry
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            # Calculate delay (exponential backoff, capped at 60s)
            if [ $RETRY_COUNT -eq 1 ]; then
              DELAY=2
            elif [ $RETRY_COUNT -eq 2 ]; then
              DELAY=4
            elif [ $RETRY_COUNT -eq 3 ]; then
              DELAY=8
            elif [ $RETRY_COUNT -eq 4 ]; then
              DELAY=16
            elif [ $RETRY_COUNT -eq 5 ]; then
              DELAY=32
            else
              DELAY=60
            fi
            
            echo "[...] Attempt $RETRY_COUNT/$MAX_RETRIES: Triggering module fetch..."
            
            # Try to fetch the module with GOPROXY=direct
            if GOPROXY=direct go get "${MODULE_PATH}@${NEXT_TAG}" 2>&1; then
              echo "[OK] Module fetch successful on attempt $RETRY_COUNT"
              SUCCESS=true
              break
            else
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "[!] Module fetch failed (attempt $RETRY_COUNT/$MAX_RETRIES)"
                echo "    Retrying in ${DELAY}s (tag may not be fully propagated yet)..."
                sleep $DELAY
              else
                echo "[!] Module fetch failed after $MAX_RETRIES attempts"
              fi
            fi
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "[!] Warning: Failed to trigger module indexing after $MAX_RETRIES attempts"
            echo "    This is non-blocking. The module will be indexed automatically when"
            echo "    someone runs 'go get' for this version, or it may take some time"
            echo "    for the proxy to discover the new tag."
            echo "    Manual check: https://pkg.go.dev/${MODULE_PATH}@${NEXT_TAG}"
          fi

      - name: Set GoReleaser args
        id: goreleaser-args
        run: |
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "args=--snapshot --clean" >> $GITHUB_OUTPUT
          else
            echo "args=release --clean" >> $GITHUB_OUTPUT
          fi

      - name: Run GoReleaser
        id: goreleaser
        uses: goreleaser/goreleaser-action@v5
        with:
          distribution: goreleaser
          version: "~> v2"
          args: ${{ steps.goreleaser-args.outputs.args }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Generate SBOM
        if: steps.goreleaser.outcome == 'success'
        id: sbom
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          NEXT_VERSION="${{ steps.version.outputs.version }}"
          SBOM_FILE=""
          
          echo "Generating SBOM for $NEXT_TAG..."
          
          if command -v syft &> /dev/null; then
            echo "Using pre-installed syft to generate SPDX JSON SBOM..."
            SBOM_FILE="touchlog-${NEXT_VERSION}.spdx.json"
            syft packages dir:. -o spdx-json > "$SBOM_FILE" || {
              echo "[!] Warning: syft failed, trying cyclonedx-gomod..."
              SBOM_FILE="touchlog-${NEXT_VERSION}.cyclonedx.json"
              go install github.com/CycloneDX/cyclonedx-gomod/cmd/cyclonedx-gomod@latest
              cyclonedx-gomod mod -json -output "$SBOM_FILE" . || {
                echo "[!] Warning: SBOM generation failed, continuing without SBOM"
                SBOM_FILE=""
                exit 0
              }
              echo "[!] Note: Generated CycloneDX format SBOM (not SPDX)"
            }
          else
            echo "Installing syft..."
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
            SBOM_FILE="touchlog-${NEXT_VERSION}.spdx.json"
            syft packages dir:. -o spdx-json > "$SBOM_FILE" || {
              echo "[!] Warning: syft failed, trying cyclonedx-gomod..."
              SBOM_FILE="touchlog-${NEXT_VERSION}.cyclonedx.json"
              go install github.com/CycloneDX/cyclonedx-gomod/cmd/cyclonedx-gomod@latest
              cyclonedx-gomod mod -json -output "$SBOM_FILE" . || {
                echo "[!] Warning: SBOM generation failed, continuing without SBOM"
                SBOM_FILE=""
                exit 0
              }
              echo "[!] Note: Generated CycloneDX format SBOM (not SPDX)"
            }
          fi
          
          if [ -n "$SBOM_FILE" ] && [ -f "$SBOM_FILE" ]; then
            echo "[OK] SBOM generated: $SBOM_FILE"
            ls -lh "$SBOM_FILE"
            echo "file=$SBOM_FILE" >> $GITHUB_OUTPUT
          else
            echo "[!] Warning: SBOM file not found after generation"
            exit 0
          fi

      - name: Upload SBOM to release
        if: steps.goreleaser.outcome == 'success' && inputs.dry_run != 'true' && steps.sbom.outputs.file != ''
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          files: ${{ steps.sbom.outputs.file }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload SBOM artifact
        if: always() && steps.sbom.outputs.file != ''
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.version.outputs.tag }}
          path: ${{ steps.sbom.outputs.file }}
          if-no-files-found: ignore

      - name: Verify Go module indexing
        if: steps.goreleaser.outcome == 'success' && inputs.dry_run != 'true'
        continue-on-error: true
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          NEXT_VERSION="${{ steps.version.outputs.version }}"
          MODULE_PATH="github.com/sv4u/touchlog/v2"
          
          echo "Verifying Go module indexing for ${MODULE_PATH}@${NEXT_TAG}..."
          echo "This may take several minutes as indexing is asynchronous."
          
          # Wait a bit for initial propagation
          echo "Waiting 10 seconds for initial tag propagation..."
          sleep 10
          
          MAX_RETRIES=5
          PROXY_SUCCESS=false
          PKG_SUCCESS=false
          
          # Retry intervals: 10s, 30s, 60s, 120s, 120s
          DELAYS=(10 30 60 120 120)
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Verification attempt $i/$MAX_RETRIES"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            
            # Check 1: Proxy API endpoint
            if [ "$PROXY_SUCCESS" = "false" ]; then
              PROXY_URL="https://proxy.golang.org/${MODULE_PATH}/@v/${NEXT_TAG}.info"
              echo "Checking proxy API: $PROXY_URL"
              
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PROXY_URL" 2>&1 || echo "000")
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "[OK] Module found in Go proxy"
                PROXY_SUCCESS=true
              elif [ "$HTTP_CODE" = "404" ]; then
                echo "[...] Module not yet in proxy (HTTP 404)"
              else
                echo "[!] Unexpected proxy response (HTTP $HTTP_CODE)"
              fi
            else
              echo "[OK] Proxy check already passed (skipping)"
            fi
            
            # Check 2: pkg.go.dev endpoint (sequential, only if proxy succeeded or on last attempt)
            if [ "$PROXY_SUCCESS" = "true" ] || [ $i -eq $MAX_RETRIES ]; then
              PKG_URL="https://pkg.go.dev/${MODULE_PATH}@${NEXT_TAG}"
              echo "Checking pkg.go.dev: $PKG_URL"
              
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PKG_URL" 2>&1 || echo "000")
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "[OK] Module indexed on pkg.go.dev"
                PKG_SUCCESS=true
              elif [ "$HTTP_CODE" = "404" ]; then
                echo "[...] Module not yet on pkg.go.dev (HTTP 404)"
              else
                echo "[!] Unexpected pkg.go.dev response (HTTP $HTTP_CODE)"
              fi
            fi
            
            # If both checks succeeded, we're done
            if [ "$PROXY_SUCCESS" = "true" ] && [ "$PKG_SUCCESS" = "true" ]; then
              echo ""
              echo "[OK] Module indexing verification complete!"
              echo "   Proxy API: ✓"
              echo "   pkg.go.dev: ✓"
              exit 0
            fi
            
            # Wait before next attempt (except on last attempt)
            if [ $i -lt $MAX_RETRIES ]; then
              DELAY=${DELAYS[$((i-1))]}
              echo ""
              echo "[...] Waiting ${DELAY}s before next attempt..."
              sleep $DELAY
            fi
          done
          
          # Final status report
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Verification Summary"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          
          if [ "$PROXY_SUCCESS" = "true" ]; then
            echo "[OK] Proxy API: Module found"
          else
            echo "[!] Proxy API: Module not yet indexed"
          fi
          
          if [ "$PKG_SUCCESS" = "true" ]; then
            echo "[OK] pkg.go.dev: Module indexed"
          else
            echo "[!] pkg.go.dev: Module not yet indexed"
          fi
          
          echo ""
          echo "[!] Warning: Module indexing verification incomplete after $MAX_RETRIES attempts"
          echo "    This is normal - Go module indexing is asynchronous and can take"
          echo "    minutes to hours. The release was successful."
          echo ""
          echo "    Manual verification links:"
          echo "    - Proxy API: https://proxy.golang.org/${MODULE_PATH}/@v/${NEXT_TAG}.info"
          echo "    - pkg.go.dev: https://pkg.go.dev/${MODULE_PATH}@${NEXT_TAG}"
          echo ""
          echo "    The module will be automatically indexed when:"
          echo "    - Someone runs 'go get ${MODULE_PATH}@${NEXT_TAG}'"
          echo "    - The Go proxy discovers the new tag (usually within hours)"

      - name: Rollback tag on failure
        if: ${{ inputs.dry_run != 'true' && steps.goreleaser.outcome == 'failure' }}
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          
          echo "[X] GoReleaser failed. Rolling back tag..."
          
          if git rev-parse --verify "$NEXT_TAG" >/dev/null 2>&1; then
            git tag -d "$NEXT_TAG"
            echo "[OK] Deleted local tag: $NEXT_TAG"
          fi
          
          if git ls-remote --tags origin "$NEXT_TAG" | grep -q "$NEXT_TAG"; then
            if git push origin ":refs/tags/$NEXT_TAG" 2>&1; then
              echo "[OK] Deleted remote tag: $NEXT_TAG"
            else
              echo "[!] Warning: Failed to delete remote tag: $NEXT_TAG"
              echo "   Manual cleanup may be required: git push origin :refs/tags/$NEXT_TAG"
            fi
          fi
          
          exit 1

      - name: Display release summary
        if: steps.goreleaser.outcome == 'success'
        run: |
          NEXT_TAG="${{ steps.version.outputs.tag }}"
          NEXT_VERSION="${{ steps.version.outputs.version }}"
          DRY_RUN="${{ inputs.dry_run }}"
          MODULE_PATH="github.com/sv4u/touchlog/v2"
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          if [ "$DRY_RUN" = "true" ]; then
            echo "[OK] DRY-RUN COMPLETED SUCCESSFULLY"
          else
            echo "[OK] RELEASE COMPLETED SUCCESSFULLY"
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Tag:     $NEXT_TAG"
          echo "Version: $NEXT_VERSION"
          if [ "$DRY_RUN" = "true" ]; then
            echo ""
            echo "[i] No tags or releases were created."
            echo "[i] Artifacts were built in snapshot mode for validation."
          else
            echo ""
            echo "Release URL: https://github.com/${{ github.repository }}/releases/tag/$NEXT_TAG"
            echo ""
            echo "Go Module Links:"
            echo "  pkg.go.dev:     https://pkg.go.dev/${MODULE_PATH}@${NEXT_TAG}"
            echo "  Proxy API:      https://proxy.golang.org/${MODULE_PATH}/@v/${NEXT_TAG}.info"
            echo ""
            echo "[i] Note: Module indexing on go.dev is asynchronous and may take"
            echo "    minutes to hours. If the module is not yet indexed, it will"
            echo "    be automatically indexed when someone runs 'go get' for this"
            echo "    version, or when the Go proxy discovers the new tag."
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"